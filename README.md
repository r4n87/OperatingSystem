# OperatingSystem 쉽게 배우는 운영체제
- [Chapter 01. Introduction to Operating System](#chapter-01-introduction-to-operating-system)
- [Chapter 02. Computer Structure](#chapter-02-computer-structure)
- [Chapter 03. Process and Thread](#chapter-03-process-and-thread)
- [Chapter 04. CPU Scheduling](#chapter-04-cpu-scheduling)
- [Chapter 05. Process Synchronization](#chapter-05-process-synchronization)

## Chapter 01. Introduction to Operating System
### 연습문제
01. 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템 자원을 효율적으로 관리하는 소프트웨어는 무엇인가? <br/>
: Operating System

02. 가전제품과 같이 CPU의 성능이 낮고 메모리 크기도 작은 시스템에 내장하도록 만든 운영체제를 무엇이라고 하는가? <br/>
: Embedded Operating System

03. 사용자가 원하는 기능을 수행하기 위해 컴퓨터 자원을 사용하는 소프트웨어는 무엇인가? <br/>
: Application Program

04. 운영체제가 없는 컴퓨터에서는 어떤 문제가 발생하는지 설명하시오. <br/>
: 사용자가 직접 자원에 접근하여 데이터가 지워지거나 덮어씌워지는 현상 발생<br/>
: 하나의 응용프로그램이 자원을 독차지하거나, 다른 응용프로그램 파괴

05. 기계와 사용자 사이에 명령을 전달하고 처리한 결과를 알려주는 것을 무엇이라고 하는가? <br/>
: Interface

06. 프로그램과 데이터를 한 번에 입력한 후 작업의 최종 결과만 얻는 운영체제 방식을 무엇이라고 하는가? <br/>
: Batch job system / Batch processing system

07. 프로그램이 진행되는 도중에 사용자로부터 데이터를 입력받아 프로그램 진행에 반영할 수 있는 운영체제 방식을 무엇이라고 하는가? <br/>
: Interactive system

08. CPU 사용 시간을 쪼개어 여러 개의 프로그램이 동시에 실행되는 것처럼 보이는 운영체제 방식을 무엇이라고 하는가? <br/>
: Time sharing system 시분할 시스템

09. 멀티프로그래밍 수준은 동시에 실행되는 작업의 개수를 나타낸다. 멀티프로그래밍 수준이 1인 시스템을 무엇이라고 하는가? <br/>
: Batch job system 일괄 작업 시스템

10. 멀티프로그래밍 수준이 2보다 크거나 같은 시스템을 두 개 이상 쓰시오. <br/>
: Hard real-time system, Soft real-time system 

11. 특정 작업이 일정 시간 안에 처리되도록 보장하는 시스템을 무엇이라고 하는가? <br/>
: Real-time system

12. 작고 싼 컴퓨터를 네트워크로 묶어 대형 컴퓨터와 같은 일을 할 수 있도록 만든 시스템을 무엇이라고 하는가? <br/>
: Distributed System 분산 시스템

13. 서버 없이 말단 노드끼리 데이터를 주고 받는 시스템을 무엇이라고 하는가? <br/>
: P2P System (Peer-to-peer)

14. 커널이 자신의 자원을 보호하기 위해 만든 함수의 집합을 무엇이라고 하는가? <br/>
: System call 시스템호출 

15. 커널과 하드웨어 사이의 인터페이스를 무엇이라고 하는가? <br/>
: Driver 드라이버

16. 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어 있는 커널 구조를 무엇이라고 하는가? <br/>
: Monolithic Architecture

17. 커널의 기능을 최소화하여 여러 컴퓨터에 이식하기 쉽게 만든 커널 구조를 무엇이라고 하는가? <br/>
: Micro Architecture

18. 서로 다른 운영체제에서 하나의 응용 프로그램으로도 작동할 수 있도록 만든 시스템을 무엇이라고 하는가? <br/>
: Virtual Machine


### 심화문제
01. 운영체제의 역할을 설명하시오.
- 자원 관리: 여러 응용 프로그램에 적당한 순서로 자원 배분, 적절한 시점에 자원 회수
- 자원 보호: 비정상적인 작업으로부터 컴퓨터 자원 보호
- 하드웨어 인터페이스 제공: 드라이버 설치를 지원함으로써 하드웨어의 종류에 상관없이 사용할 수 있게 함
- 사용자 인터페이스 제공: 사용자가 운영체제를 편리하게 사용할 수 있도록 지원

02. 운영체제의 목표를 설명하시오.
- 효율성: 같은 자원을 사용하여 더 많은 작업량 처리 or 같은 작업량을 처리하는 데 보다 적은 자원 사용
- 안정성: 사용자와 응용 프로그램의 안전 문제와 하드웨어적인 보안 문제 처리, 이전으로 복구하는 결함 포용 기능 수행
- 확장성: 플러그 앤드 플레이 기능 제공, 앞으로 개발될 하드웨어도 제약 없이 사용할 수 있도록 제작자의 편리성 고려
- 편리성: 사용자가 편리하게 작업할 수 있는 환경 제공

03. CPU 집중 작업과 입출력 집중 작업에 대해 설명하시오.
- CPU 집중 작업: 프로그램이 실행되는 동안 입출력 불가, CPU만 사용하는 계산 작업
- 입출력 집중 작업: 프로그램이 실행되는 동안 입출력 가능, 대부분의 작업을 입력과 출력에 사용

04. 실시간 시스템에 대해 설명하시오.
- 특정 시스템에서 일정 시간 안에 작업이 처리되도록 보장하는 시스템
- 지정한 응답 시간을 정확히 지키는 경성 시스템과, 최대한 지키지만 융통성이 어느 정도 허용되는 연성 시스템이 있음

05. 클라우드 컴퓨팅에 대해 설명하시오.
- 언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경
- 그리드 컴퓨팅 + SaaS(Software as a Service)
- 서버 관리와 네트워크 관리를 클라우드 서버 제공자가 수행함

06. API와 SDK를 비교하여 설명하시오.
- API(application Programming Interface): 응용프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스, 시스템 호출보다 광범위한 범위 (ex)System call이 운영체제의 API
- SDK(System Developer's Kit): 프로그램 개발자를 위해 API 및 api 사용 매뉴얼, 코드 편집기와 에뮬레이터 등 응용 프로그램까지 묶어 배포하는 개발툴 (ex) Android Studio

07. 단일형 구조 커널의 특징을 설명하시오.
- 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어 있음
- (ex) MS-DOS, VMS, 초기의 유닉스
- 장점: 모듈 간의 통신 비용이 줄어 효율적 운영 가능
- 단점: 버그나 오류 처리가 어려움, 상호 의존성이 높아서 결함 확산성이 높음, 다양한 환경 시스템에 적용이 어려움

08. 마이크로 구조 커널의 특징을 설명하시오.
- 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 기본적인 기능만 제공
- 다른 커널에 비해 운영체제의 많은 부분이 사용자 영역에 구현됨
- 커널은 메모리 관리와 프로세스 간의 동기화 서비스 제공
- 메모리 관리자와 동기화 모듈은 프로세스 간 통신 모듈로 연결
- (ex) Mach
- 장점: 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않음


## Chapter 02. Computer Structure
### 연습문제
01. CPU의 구성에 대해 설명하시오.<br/>
: 산술논리 연산장치, 제어장치, 데이터 임시 보관

02. 폰노이만 구조의 가장 중요한 특징을 설명하시오. <br/>
: 모든 프로그램은 메모리에 올라와야 실행할 수 있다.

03. 버스의 종류를 나열하시오. <br/>
: 제어 버스, 주소 버스, 데이터 버스

04. 단방향 버스에 대해 설명하시오. <br/>

05. 다음에 실행할 명령어 주소를 가지고 있는 레지스터는 무엇인가? <br/>
: 프로그램 카운터(PC)

06. 다음에 실령할 명령어를 보관하는 레지스터는 무엇인가? <br/>
: Instruction register 명령어 레지스터

07. 메모리 주소를 보관하는 레지스터는 무엇인가? <br/>
: Memory Address Register 메모리 주소 레지스터

08. 메모리에 저장할 데이터나 메모리에서 가져온 데이터를 임시로 보관하는 레지스터는 무엇인가? <br/>
: Memory Buffer Register 메모리 버퍼 레지스터

09. 주소 버스와 연결되어 있는 레지스터는 무엇인가? <br/>
: Memory Address Register 메모리 주소 레지스터

10. 데이터 버스와 연결되어 있는 레지스터는 무엇인가? <br/>
: Memory Buffer Register 메모리 버퍼 레지스터

11. 프로그램을 보호하기 위해 사용하는 두 가지 레지스터는 무엇인가? <br/>
: Bound Register, Limit Register

12. 속도 차이가 나는 두 장치 사이에서 속도를 완화하는 장치를 무엇이라고 통칭하는가? <br/>
: Buffer

13. 응용 프로그램과 프린터 사이에서 속도 차이를 완화하는 소프트웨어를 무엇이라고 하는가? <br/>
: SPOOL

14. 부팅 시 운영체제를 메모리로 가져오기 위해 사용하는 작은 프로그램은 무엇인가? <br/>
: Bootstrap

15. 속도가 빠르고 값이 비싼 저장장치를 CPU 가까운 쪽에 두고, 값이 싸고 용량이 큰 저장장치를 반대쪽에 배열하는 방식은 무엇이라고 하는가? <br/>
: Storage Hierarchy

16. 작업의 효율성을 높이기 위해 CPU가 입출력 관리자에게 입출력 작업을 요청하면 작업을 마친 입출력 관리자는 CPU에 무엇을 보내는가? <br/>
: Interrupt

17. CPU의 도움 없이도 메모리를 사용할 수 있도록 입출력 관리자에게 주는 권한을 무엇이라고 하는가? <br/>
: DMA(Direct Memory Access)

18. CPU와 입출력 관리자가 서로 다른 메모리 영역을 사용하는 기법을 무엇이라고 하는가? <br/>
: MMIO(Memory Mapped I/O)

19. CPU가 병렬 처리를 지원하지 않을 때 소프트웨어적으로 병렬 처리를 하는 기법을 무엇이라고 하는가? <br/>
: VLIW(Very Long Instruction Word)

### 심화문제
01. 컴퓨터에서 클록이 하는 역할을 설명하시오.
- CPU 작업의 박자
- 클록이 일정 간격으로 틱을 만들면, 틱에 맞춰 CPU의 구성 부품이 작업을 함

02. 프로그램 카운터 레지스터의 역할을 설명하시오.
- 다음에 실행할 명령어의 주소를 기억하고 제어장치에 알려줌
- Instruction Pointer

03. 제어 버스, 주소 버스, 데이터 버스에 대해 설명하시오.
- 제어 버스: 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 감 / CPU, 메모리, 주변장치와 양방향
- 주소 버스: 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지를 알려주는 위치 정보가 오고 감 / CPU -> 주소, 주소-> 메모리&주변장치 단방향
- 데이터 버스: 제어버스와 주소 버스가 작업을 하면 데이터가 데이터 버스에 실려 목적지까지 이동 / 메모리 버퍼 레지스터와 양방향

04. 휘발성 메모리와 비휘발성 메모리를 비교하여 설명하시오.
- 휘발성 메모리: DRAM, SRAM, SDRAM / 속도가 빠르나 전력이 끊기면 데이터가 사라짐
- 비휘발성 메모리: Flash memory, FRAM, PRAM / 전력이 없어도 데이터를 보관할 수 있으나 메모리 내부가 복잡하고 속도가 느리며 가격이 비쌈

05. DDR SDRAM에 대해 설명하시오.
- 기존 SDRAM이 메인보드의 시스템 버스와 같은 속도로 작동하여, CPU와의 속도 차이가 발생
- 속도 차이를 완화하기 위하여 SDRAM의 대역폭을 늘려 데이터의 입출력 속도를 빠르게 한 것이 DDR(Double Data Rate) SDRAM
- 1차선 도로와 2차선 도로의 차이와 같이 더 빠르게 저장할 수 있음

06. 스풀에 대해 설명하시오.
- CPU와 입출력 장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼
- Buffer와는 다르게 프로그램간 배타적

07. 즉시 쓰기 방식의 캐시와 지연 쓰기 방식의 캐시를 비교하여 설명하시오.
- 즉시 쓰기(write through): 캐시에 있는 데이터 변경 시 즉시 메모리에 반영 / (+)항상 최신값 유지 / (-)빈번한 데이터 전송으로 성능이 느림 
- 지연 쓰기(write back): 캐시에 있는 데이터 변경 시 내용을 모아 주기적으로 메모리에 반영 / (+)성능 향상 / (-)메모리와 캐시 데이터 사이 불일치 발생 가능

08. 인터럽트 번호를 사용하는 이유를 설명하시오.
- 많은 주변 장치 중 어떤 것의 작업이 끝났는지를 CPU에 알려주기 위해 사용
- 장치의 고유 번호로, 운영체제마다 다름

09. 메모리 직접 접근(DMA)에 대해 설명하시오.
- 인터럽트 방식을 사용하면서 입출력 관리자가 데이터의 입출력을 맡음
- CPU에 허락 없이 메모리에 접근할 수 있는 권한

10. 메모리 매핑 입출력에 대해 설명하시오.
- DMA를 통해 들어온 데이터가 CPU 데이터와 섞여 혼란을 불러오는 것을 마ㅏㄱ기 위해 도입됨
- CPU가 사용하는 메모리 공간과 직접 메모리 접근 공간을 분리
- MMIO(Memory Mapped I/O)


## Chapter 03. Process and Thread
### 연습문제
01. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?  
: PCB(Process Control Block) 프로세스 제어 블록

02. 프로세스의 상태 중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?  
: Ready Status 준비상태

03. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?  
: Blocking Status 대기 상태

04. CPU 스케줄러가 준비 상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?  
: Dispatch 

05. 유닉스에서 Ctrl+Z 키를 눌러 프로세스가 중단되면 프로세스는 어떤 상태로 바뀌는가?  
: 정지(Stop)/휴식 상태로 사용하던 데이터 메모리와 PCB가 유지되어 해당 지점부터 재시작할 수 있음

06. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?  
: Context Switching 문맥 교환

07. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?  
: fork()

08. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?  
: exec()

09. 부모 프로세스가 기다리지 않아 자원이 회수되지 못하고 계속 살아 있는 프로세스는 무엇인가?  
: Orphan Process 고아 프로세스

10. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?  
: Thread 스레드

11. 고아 프로세스를 방지하기 위해 부모 프로세스는 어떤 시스템 호출을 사용하는가?  
: wait()

12. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?  
: GC(Garbage Collection)

13. 모든 프로세스를 부모-자식 관계로 만들어 자원 회수를 용이하게 하는 프로세스의 구조는 무엇인가?  
: 프로세스 계층 구조

### 심화문제
01. 다섯 가지 프로세스 상태도를 그리시오.
- Create: 메모리 할당, PCB 할당 후 Ready 상태
- Ready: Ready Queue에서 대기, CPU 스케줄러에 의해 관리 / dispatch 시 Running으로 이동
- Running: 프로세스가 CPU 할당을 받아 실행됨 / timeout 시 Ready, exit 시 Terminate, block 시 Blocking 상태로 이동
- Terminate: 정상종료(exit)와 비정상종료(abort) 포함, 메모리 및 PCB 삭제
- Blocking: 실행에서 입출력을 받아 이동한 상태 / 입출력 완료되어 wakeup 시 Ready로 이동

02. 프로세스의 상태 중 휴식 상태와 보류 상태에 대해 설명하시오.
- Pause: 실행을 잠시 멈춘 상태로, 데이터와 PCB가 유지됨. 그대로 재시작 가능 / 프로세스가 메모리에 있는 상태
- Suspend: 프로세스가 메모리에서 쫓겨난 상태 / 프로세스가 스왑 영역에 있는 상태

03. 프로세스 제어 블록의 구성에 대해 설명하시오.
- Process Control Block
- Task Control Block
- 프로세스 생성 시 만들어져, 프로세스 실행 완료 시 폐기
- 포인터, 프로세스 상태, 프로세스 구분자, 프로그램 카운터, 프로세스 우선순위, 각종 레지스터 정보, 메모리 관리 정보, 할당된 자원 정보, 계정 정보, PPID와 CPID 정보 등 포함

04. 문맥 교환에 대해 설명하시오.
- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
- 두 PCB 내용이 변경됨

05. 프로세스를 구성하는 코드 영역, 데이터 영역, 스택 영역에 대해 설명하시오.
- 코드 영역: 프로그램 본문이 기술, 텍스트 영역 / Read only 
- 데이터 영역: 코드가 실행되면서 사용하는 변수나 파일 등 각종 데이터 저장 / Read and Write
- 스택 영역: 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터 저장 / Hidden

06. fork() 시스템 호출의 장점을 설명하시오.
- 프로세스 생성 속도가 빠름: 기존 메모리 복사
- 추가 작업 없이 자원 상속: 부모 프로세스로부터 상속받음
- 시스템 관리 효율적: 부모-자식 프로세스가 연결이 되어 있어, 자식 프로세스 종료 시 부모 프로세스가 관리

07. exec() 시스템 호출을 사용하는 이유를 설명하시오.
- 프로세스의 구조체를 재활용
- 새로운 프로세스를 만들 경우 PCB를 만들고, 메모리 자리 확보하고, GC작업을 위해 P-C 관계 생성 필요
- exec() 수행 시에는 이미 만들어진 PCB, 메모리, P-C 관계 활용 가능

08. 프로세스 계층 구조의 장점을 설명하시오.
- 여러 작업 동시 처리: fork()를 통해 프로세스 복사 가능, exec()을 통해 기존 프로세스 자리 활용 가능
- 용이한 자원 회수: 프로세스 간 책임 관계까 분명해져 자원을 회수하기 쉬워짐

09. 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU 멀티스레드를 비교하여 설명하시오.
- Multi-Thread: 프로세스 내 작업을 여러개의 스레드로 분할, 작업의 부담을 줄이는 프로세스 운영 기법
- Multi-Tasking: 운영체제가 CPU에 작업을 줄 때 시간을 나누어 배분하는 기법 / Time-Sharing System
- Multi-Processing: 다수의 CPU + 다수의 스레드
- CPU Multi-Thread: 파이프라인 기법을 통해 여러 스레드를 동시에 처리하도록 만든 병렬 처리 기법 


## Chapter 04. CPU Scheduling
### 정리
CPU 스케줄러
- 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정
- = Process Scheduler

고수준 스케줄링
- long-term scheduling, job scheduling, admission scheduling
- 시스템 내의 전체 작업 수를 조절
- 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
- 시스템 내에서 동시 실행 가능한 프로세스의 총 개수가 결정: 멀티프로그래밍 정도
- 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업 처리 시 사용
- 작업 대기 > 보류 프로세스

중간 수준 스케줄링
- 중지, 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막음
- 보류 상태
- buffer
- 보류 프로세스 > 활성 프로세스, 활성 프로세스 > 보류 프로세스

저수준 스케줄링
- short-term scheduling
- 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 결정
- 활성 프로세스 > 실행 프로세스, 실행 프로세스 > 활성 프로세스

스케줄링 목적
- 공평성: 모든 프로세스가 자원을 공평하게 배정받도록
- 효율성: 시스템 자원이 유휴 시간 없이 사용되도록, 유휴 자원을 사용하는 프로세스에는 우선권을
- 안정성: 중요 프로세스에 우선순위를 사용하여 먼저 작동하도록 배정하여 시스템 자원을 점유하거나 파괴하는 프로세스로부터 자원 보호
- 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록
- 반응 시간 보장: 응답이 없는 경우 적절한 시간 안에 프로세스의 요구에 반응
- 무한 연기 방지: 특정 프로세스의 작업이 무한 연기되지 않도록

선점형 스케줄링
- 프로세스가 CPU를 할당받아 실행 중이라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링
- (ex) 인터럽트, 대부분이 저수준 스케줄러
- (-) 문맥 교환 같은 부가 작업으로 낭비 발생
- (+) 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합

비선점형 스케줄링
- 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링
- (ex) 과거 일괄 작업 시스템
- (+) 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비가 적음
- (-) 사용 기간이 긴 프로세스 때문에 짧은 여러 프로세스가 기다려 전체 시스템의 처리율 저하

프로세스 우선순위
- 커널 프로세스 > 일반 프로세스
- 입출력 프로세스 > CPU 프로세스
- 전면 프로세스 > 후면 프로세스
- 대화형 프로세스 > 일괄 처리 프로세스

다중 큐
1) 준비 상태의 다중 큐
  - PCB 우선순위를 매번 검색하지 않도록, 우선순위에 따른 큐를 만듦
  - 고정 우선순위: 운영체제가 프로세스에 우선순위 부여 시 프로세스가 끝날 때까지 바뀌지 않음. 변화에 대응이 어려워 효율이 떨어짐
  - 변동 우선순위: 프로세스 작업 중간에 우선순위가 변할 수 있음. 구현이 어렵지만 효율성이 높음 / priority inversion
2) 대기 상태의 다중 큐
  - 입출력이 완료되기를 기다리는 프로세스가 모여있음
  - 다양한 종류의 입출력장치가 있기 때문에 동일 입출력 요구한 프로세스끼리 같은 큐에 모음
  - interrupt vector: 동시에 끝나는 인터럽트를 처리하기 위한 자료 구조

스케줄링 알고리즘
선택 기준
- CPU 사용률: CPU 사용 시간 측정
- 처리량: 단위 시간당 작업을 마친 프로세스 수
- 대기 시간: 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
- 응답 시간: 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
- 반환 시간: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간 / 대기 시간 + 실행 시간

FCFS
- First Come First Served
- 비선점형/선입선출
- 큐가 하나로 모든 프로세스의 우선순위가 동일
(+) 단순하고 공평함
(-) Convoy effect(호위 효과) 발생

SJF
- Shortest Job First
- 비선점형/최단 작업 우선 스케줄링
(+) FCFS 스케줄링보다 효율성이 높음
(-) 운영체제가 프로세스 종료 시간 정확하게 예측하지 못하고, 공평하지 못함

HRN
- Highest Response Ratio Next
- 비선점형/최고 응답률 우선 스케줄링
- 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링 / 우선 순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간
(+) 아사 현상 완화
(-) 여전히 공평성 위배

라운드 로빈 스케줄링
- Round Robin Scheduling
- 선점형
- 순환 순서 방식/최대 시간, 타임 슬라이스
(+) 콘베이 효과가 줄어듦
(-) 문맥 교환 시간이 추가

SRT 우선 스케줄링
- Shortest Remaining Time
- 선점형/최소 잔류 시간 우선 스케줄링
- SJF + 라운드 로빈
- 남아 있는 작업 시간이 가장 적은 프로세스 선택
(-) 남은 시간을 주기적으로 계산, 문맥 교환으로 작업 추가
(-) 아사 현상 발생

우선순위 스케줄: 프로세스의 중요도에 따라 우선순위 적용
다단계 큐 스케줄링
- Multilevel Queue
- 선점형
- 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
- 라운드 로빈 방식의 큐
- 우선순위에 따라 다양한 스케줄링 가능
(-) 우선순위가 높은 상위 큐 작업이 끝나기 전에는 하위 큐 프로세스 작업 불가

다단계 피드백 큐 스케줄링
- Multilevel feedback Queue
- 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링 보완
- CPU 사용 후 프로세스의 우선순위가 하나 낮아짐
- 커널 프로세스는 일반 프로세스의 큐에 삽입되지는 않음
- 우선순위에 따라 타임 슬라이스의 크기가 다름(낮을 수록 타임 슬라이스 크기가 큼)

인터럽트 처리
- 입출력 시 인터럽트를 사용하여 시스템 효율을 높임
- 입출력을 요청하고 입출력이 완료되면 이벤트를 발생시키는 것
- 동기적 인터럽트: 실행중인 명령어로 발생
  - 프로그램 상의 문제로 발생 (ex)다른 사용자의 메모리 영역 접근, 오버플로, 언더플로
  - 컴퓨터 작업자가 의도적으로 프로세스 중단 (ex)Ctrl+C
  - 입출력장치 같은 주변장치 조작
  - 산술 연산 (ex)/0
- 비동기적 인터럽트: 실행 중인 명령어와 무관하게 발생
  - 하드디스크 읽기 오류, 메모리 불량
  - 키보드 인터럽트, 마우스 인터럽트
1) 인터럽트 발생 시 현재 실행 중인 프로세스 일시 정지, 현재 프로세스 관련 정보를 임시 저장
2) 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서 결정
3) 인터럽트 벡터에 등록된 인터럽트 핸들러 실행
4) 핸들러 종료 시 일시 정지된 프로세스가 다시 실행되거나 종료

### 연습문제
01. 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?  
: 고수준 스케줄링

02. 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?  
: 저수준 스케줄링

03. 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?  
: 선점형 스케줄링

04. 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?  
: 전면 프로세스

05. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?  
: FCFS

06. 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?  
: SJF

07. SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라 하는가?  
: starvation, infinite blocking

08. 아사 현상을 해결하는 방법을 설명하시오.  
: 운영체제에게 프로세스 작업 시간 알림, 에이징(aging)

09. 서비스를 받기 위해 대기한 시간과 CPU 사용 시간을 고려하여 우선순위를 정하는 스케줄링 알고리즘은 무엇인가?  
: SRT 우선 스케줄링

10. 프로세스가 할당받은 시간(타임 슬라이스)동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?  
: 라운드 로빈 스케줄링

11. 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.  
: 큰 경우, FCFS와 동일 / 작은 경우, 문맥 교환에 걸리는 시간이 작업 시간보다 상대적으로 커져 많은 시간 낭비

12. 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?  
: HRN 최고 응답률 우선 스케줄링

13. 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?  
: 다단계 큐 스케줄링

14. 우선순위에 따라 준비 큐를 여러 개 사용하며, 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특징을 가진 스케줄링 알고리즘은 무엇인가?
: 다단계 피드백 큐 스케줄링

15. 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?  
: 무한

16. 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?  
: 커짐

17. 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?  
: FCFS

### 심화문제
01. 스케줄링 단계와 그 특징을 설명하시오. (정리)

02. 스케줄링의 목적을 설명하시오. (정리)

03. 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오. (정리)

04. 스케줄링 알고리즘의 선택 기준에 대해 설명하시오. (정리)

05. FCFS, SJF, HRN 스케줄링의 특징을 설명하시오. (정리)

06. 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오. (정리)

07. 아사 현상과 에이징에 대해 설명하시오.
- 아사 현상: 우선순위가 낮은 프로세스가 실행되지 못하는 현상
- 에이징: 프로세스가 양보할 수 있는 상한선을 정하는 방식. 상한선에 도달하면 무조건 실행

08. 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오.
- 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 결정해야 시스템 효율이 최적화됨
- 타임 슬라이스가 큰 경우, FCFS 스케줄링의 문제 발생
- 타임 슬라이스가 작은 경우, 문맥 교환에 많은 시간을 낭비함


## Chapter 05. Process Synchronization
### 정리
프로세스 통신
- IPC(Inter-Process Communication)
- 운영체제X: 전역 변수, 파일
- 운영체제O: 파이프, 소켓, 원격 프로시저 호출(RPC)
- 프로세스 내부 통신: 프로세스 내 2개 이상의 스레드가 있는 경우, 전역변수 or 파일 사용
- 프로세스 간 통신: 같은 컴퓨터 내 여러 프로세스끼리 통신, 공용 파일 or 운영체제 제공 파이프 사용
- 네트워크 이용 통신: 다른 컴퓨터의 프로세스와 통신, 소켓 or RPC 사용

프로세스 간 통신 분류
1. 통신 방향에 따른 분류
- 양방향 통신: 데이터를 동시에 양쪽 방향으로 전송, 소켓 통신
- 반양방향 통신: 동시 양쪽 방향 전송 불가, 특정 시점에 한쪽 방향 전송 가능, 무전기
- 단방향 통신: 한쪽 방향으로만 데이터 전송, 전역 변수와 파이프

2. 통신 구현 방식에 따른 분류
- 동기화 기능이 있느냐 없느냐
- 대기가 있는 통신: 동기화 지원, 데이터 도착 시까지 자동으로 대기 상태, 파이프 or 소켓
- 대기가 없는 통신: 동기화 미지원, 바쁜 대기를 사용하여 도착했는지 여부 확인(busy waiting), 전역변수 or 파일

프로세스 간 통신 종류
1. 전역 변수
- 공동으로 관리하는 메모리를 사용
- 직접적으로 관련이 있는 프로세스 간 사용 (ex)부모 프로세스, 자식 프로세스
- (-) 동기화 문제. 바쁜 대기를 통해 전역 변수를 계속 확인해야 함

2. 파일
- 저장장치에 파일을 읽고 쓰는 코드
- open, write, read, close
- open: 파일이 있는지, 쓰기 권한이 있는지 확인. 접근 가능할 경우 file descriptor를 얻어 파일에 접근
- read or write: file descriptor를 통해 진행
- close: close(fd) 함수 사용
- 부모-자식 프로세스 간 통신에 많이 사용
(-) 동기화 문제. 프로세스가 알아서 동기화, 주로 부모 프로세스에서 wait() 사용

3. 파이프
- 운영체제가 제공하는 동기화 통신 방식
- 단방향 통신으로, 양방향 통신을 하려면 2개 이상 사용
- 바쁜 대기를 하지 않음
- 이름 없는 파이프: 일반적 파이프, 부모와 자식 프로세스와 같이 서로 관련 있는 프로세스 간 통신에 사용
- 이름 없는 파이프: FIFO라 불리는 특수 파일 이용, 서로 관련 없는 프로세스 간 통신에 사용

4. 소켓
- 네트워킹에 사용
- 컴퓨터 위치 파악, 원격지 시스템 내 어떤 프로세스와 통신을 할지 결정
- 프로세스간 동기화 지원, 양방향 통신 지원

공유 자원
- Shared Resource
- 프로세스가 공동으로 이용하는 변수, 메모리, 파일
- 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 경쟁 조건(race condition) 발생 가능

임계 구역
- Critical Section
- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램 영역
- 특정 프로세스가 임계 구역 안으로 들어가면, 다른 프로세스는 임계 구역 밖에서 기다려야 함

생산자-소비자 문제
- Producer-Consumer Problem
- 임계구역과 관련된 문제

임계구역 해결 조건
- 상호 배제(Mutual Exclusion): 임계구역 내에는 한 번에 하나의 프로세스만
- 한정 대기(Bounded Waiting): 어떤 프로세스도 무한대기 하지 않아야 함
- 진행의 융통성(Progress Flexibility): 한 프로세스가다른 프로세스의 진행을 방해하면 안됨

임계구역 해결 방법
- 잠금, 잠금 해제, 동기화 사용

상호 배제 문제
- boolean lock을 공유 변수로 사용하여 임계구역 진입 보호
(-) timeout으로 인하여 동시 임계 구간 진입이 발생하여 상호 배제 조건을 보장하지 못함
(-) 잠금이 풀리기를 기다리며 바쁜 대기, 시스템 자원 낭비

한정 대기 문제
- boolean lock 2개를 공유 변수로 사용하여 임계구역 진입 보호
(+) 상호 배제 보장
(-) 교착(deadlock): 모두 임계구역에 진입하지 못하는 무한 대기 현상 발생
(-) 프로세스가 늘어나면 공유 변수의 개수도 늘려야 하는 비효율성

진행의 융통성 문제
- int lock을 공유 변수로 사용하여 임계구역 진입 보호
(+) 상호 배제, 한정 대기 보장
(-) 경직된 동기화(lockstep synchronization): 프로세스의 우선순위에 상관없이 번갈아가며 임계구역 진입

하드웨어적 해결 방법
- 검사와 지정(test-and-set) 코드 사용
(-) 바쁜 대기를 사용하여 검사, 자원 낭비

피터슨 알고리즘
- boolean lock 2개, int turn을 공유 변수로 사용
(+) 임계구역 해결의 세 가지 조건을 모두 만족
(-) 2개의 프로세스만 사용 가능, 프로세스 추가 시 공유 변수를 추가하고 코드를 변경해야 함
(-) 구조가 복잡하여 사용하지 않음

데커 알고리즘
- boolean lock 2개, int turn을 공유 변수로 사용
(+) 임계구역 해결의 세 가지 조건을 모두 만족, 하드웨어의 도움 없이 진행
(-) 프로세스가 늘어나면 변수도 늘어나고 전체적인 알고리즘이 복잡해짐

세마포어
- 임계구역이 잠겼는지 직접 점검, 바쁜 대기, 동기화 메세지를 보낼 필요가 없음
- Semaphore(n): 초기 설정을 통해 공유 가능한 자원의 수 지정
- P(): 잠금 수행 코드 RS-=1 or block()
- V(): 잠금 해제 코드 RS+=1 + wake_up()
- P,V 내부 코드에 검사와 지정을 사용하여 분리 실행하지 않고 완전히 실행하게 해야 함

모니터
- 세마포어에서 잘못된 사용으로 인해 임계구역이 보호받지 못하는 경우를 보완
- 모든 프로세스가 세마포어 알고리즘을 따른다면, P() V()를 사용하지 않고 자동으로 처리
- 공유자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공
- 자원 보호, 프로세스 간 동기화 / 시스템 호출
- 내부적으로 상태 변수를 사용하여 임계구역의 보호와 동기화 수행
- wait(): P()
- signal(): V()

파일
- 순차 파일, 순차적 접근
- lseek(): 파일 기술자 옮기는 함수
- fork() 시 파일 기술자 복사, open()은 한 번이라도 close()는 두 번 수행

파이프
- read()와 write()의 기술자가 따로 존재
- close()를 네 번 수행
- 대기가 있는 통신이기 때문에 wait()가 필요 없음

네트워킹
- 소켓 사용
- 양방향 통신, 동기화 지원
- 클라이언트: socket() - connect() - read()/write() - close()
- 서버: socket() - bind() - listen() - accept() - read()/write() - close()
- connect() > accept()를 통해 양방향 통신 시작, 소켓 기술자가 생성되고 작업이 시작됨

### 연습문제
01. 프로세스 간 통신에서 데이터를 양방향으로 전송 가능하지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 통신 방식은 무엇인가?  
: 반양방향 통신

02. 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 무엇이라 하는가?  
: 바쁜 대기busy waiting

03. 프로세스 간 통신에서 대기가 없는 통신과 대기가 있는 통신의 예를 각각 제시하시오.  
: 대기가 없는 통신 - 전역 변수, 파일 / 대기가 있는 통신 - 파이프, 소켓

04. 파이프를 이용하여 통신할 때 파이프를 2개 사용하는 이유는 무엇인가?  
: 파이프는 단방향 통신만 지원하므로, 양방향 통신을 하기 위해서는 파이프가 2개 필요함

05. 공유 자원을 병행적으로 읽거나 쓰는 상황을 무엇이라 하는가?  
: 경쟁 상황 race condition

06. 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역은 무엇인가?  
: 임계구역 critical section

07. 임계구역 해결 조건 중 한 프로세스가 임계구역에 들어갔을 때 다른 프로세스는 임계구역에 들어갈 수 없는 조건을 무엇이라 하는가?  
: 상호 배제 mutual exclusion

08. 임계구역 해결 조건 중 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 조건을 무엇이라고 하는가?  
: 진행의 융통성 progress flexibility

09. 임계구역 문제를 하드웨어적으로 해결한 방식으로, 하드웨어의 지원을 받아 명령어를 실행하는 도중에 타임아웃이 걸리지 않도록 하는 방식을 무엇이라 하는가?  
: 검사와 지정 test-and-set

10. 세마포어의 Semaphore(n)에서 n은 무엇을 가리키는가?  
: 공유자원의 수

11. 세마포어에서 내부 변수를 RS라고 할 때 세마포어 P()의 내부 코드를 쓰시오.  
: if(0 < RS) { RS -= 1; } else { block(); }

12. 세마포어에서 내부 변수를 RS라고 할 때 세마포어 V()의 내부 코드를 쓰시오.
: RS += 1; wake_up();

13. 세마포어가 제대로 작동하지 않는 경우를 설명하시오.  
: P()를 두 번 사용, V()와 P()를 거꾸로 사용 

14. 세마포어의 내부 코드도 타임아웃이 걸리면 문제가 발생할 수도 있다. 그래서 내부 코드는 무엇으로 보호받는가?  
: 검사와 지정 test-and-set

15. 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시키는 것으로, 세마포어의 단점을 해결하면서 임계구역 문제를 해결한 방식은 무엇인가?  
: 모니터 Monitor

### 심화문제
01. 프로세스 간 통신을 통신 방향에 따라 분류하여 설명하시오.  
- 양방향: 양방향 통신 가능, 소켓
- 반양방향: 순서에 따라 양방향 통신 가능, 무전기
- 단방향: 한 방향으로만 통신 가능, 전역 변수 or 파이프

02. 대기가 있는 통신과 대기가 없는 통신의 의미를 설명하고 적절한 예를 제시하시오.
- 대기가 있는 통신: 동기화 지원, 데이터 도착 시까지 자동으로 대기 상태, 파이프 or 소켓
- 대기가 없는 통신: 동기화 미지원, 바쁜 대기를 사용하여 도착했는지 여부 확인(busy waiting), 전역변수 or 파일

03. 실생활의 예를 들어 임계구역 문제를 설명하시오.
- 쇼핑몰에서 재고가 1개 남은 물건이었는데, 인터넷 주문이 들어왔으나 오프라인 고객이 먼저 물건을 가져간 경우. 
- 인터넷 주문자가 먼저 주문했으나 물건 재고가 없어 제공 불가
- 주문이 오프라인으로 바로 동기화되지 않아 임계구역 문제 발생

04. 다음 코드의 문제점을 설명하시오.
- boolean lock 공유 변수 1개 사용
- 상호 배제 문제 발생
(-) timeout으로 인하여 동시 임계 구간 진입이 발생하여 상호 배제 조건을 보장하지 못함
(-) 잠금이 풀리기를 기다리며 바쁜 대기, 시스템 자원 낭비
